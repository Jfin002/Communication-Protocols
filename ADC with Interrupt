Main.c:

#include <stdio.h>
#include <stdint.h>
#include "stm32f4xx.h"
#include "ADC_with_Interrupt.h"


uint32_t sensor_value;
static void adc_callback(void);
int main()
{
	PA1_ADC_Interrupt_Init();
	start_conversion();

	while(1)
	{

	}
}

       /*CLICK DEBUG -> SWITCH -> LIVE EXPRESSION : ADD NEW = SENSOR VALUE
		THEN CLICK ON RESUME ICON
		CONTINUOUS VALUE WILL DISPLAYED*/
static void adc_callback(void)
{
	sensor_value = ADC1 ->DR;
	//printf("sensor value : %d \n\t",(int)sensor_value);

}
void ADC_IRQHandler(void)
{
	if((ADC1 ->SR & SR_EOC)!=0)
	{
		//CLEAR EOC
		ADC1->SR &=~ SR_EOC;

		adc_callback();
	}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Source file:

/*
 * ADC_with_Interrupt.c
 *
 *  Created on: Jan 28, 2026
 *      Author: jeffin
 */


#include "stm32f4xx.h"
#include "ADC_with_Interrupt.h"

#define GPIOAEN         (1<<0)
#define ADC1EN        	(1<<8)
#define ADC_CH1         (1<<0)
#define ADC_SEQ_LEN_1     0x00
#define CR2_ADON        (1<<0)
#define CR2_SWSTART     (1<<30)
#define CR2_CONT        (1<<1)
#define CR1_EOCIE        (1<<5)



void PA1_ADC_Interrupt_Init(void)
{
	/*1.CONFIGURE GPIO PIN BELONGS TO ADC1 CHANNEL WITH DATASHEET FROM PG NO. 39 TABLE 8
		HERE PA1 - ADC1_1 CHANNEL
		ENABLING CORRESPONDING DATA BUS OF GPIO PORTA WITH REFERENCE MANUAL 6.3.1 RCC GPIOD*/
		RCC ->AHB1ENR |= GPIOAEN;
	    /* 2 SETTING PA1 TO ANALOG MODE WITH REFERENCE MANUAL 8.4.1*/
		GPIOA ->MODER |= (1U<<2);
		GPIOA ->MODER |= (1U<<3);

		/*3 ENABLING CORRESPONDING DATA BUS OF ADC1 WITH REFERENCE MANUAL 6.3.12 RCC APB2ENR*/
			RCC->APB2ENR |= ADC1EN;
		/*	ENABLE ADC END-OF-CONVERSION INTERRUPT
		 *  USING CONTROL REGISTER 1 IN  REFERENCE MANUAL 11.12.2
		 */
			ADC1->CR1 |= CR1_EOCIE;

			// ENABLE ADC INTERRUPT IN NVIC
			NVIC_EnableIRQ(ADC_IRQn);

			/*4. CONVERSION SEQUENCE START
			SEQUENCE REGISTER FOR CHANNEL 1 WITH REFERENCE MANUAL 11.12.11 */
			ADC1->SQR3 = ADC_CH1;
			//SEQUENCE REGISTER FOR LENGTH OF CONVERSION WITH REFERENCE MANUAL 11.12.9
			ADC1->SQR1 = ADC_SEQ_LEN_1;

			//CONTROL REGISTER TO ENABLE ADC MODULE WITH REFERENCE MANUAL 11.12.3
			ADC1->CR2 |= CR2_ADON;

}


void PA1_ADC_Init(void)
{
	/*1.CONFIGURE GPIO PIN BELONGS TO ADC1 CHANNEL WITH DATASHEET FROM PG NO. 39 TABLE 8
		HERE PA1 - ADC1_1 CHANNEL
		ENABLING CORRESPONDING DATA BUS OF GPIO PORTA WITH REFERENCE MANUAL 6.3.1 RCC GPIOD*/
		RCC ->AHB1ENR |= GPIOAEN;
	    /* 2 SETTING PA1 TO ANALOG MODE WITH REFERENCE MANUAL 8.4.1*/
		GPIOA ->MODER |= (1U<<2);
		GPIOA ->MODER |= (1U<<3);

		/*3 ENABLING CORRESPONDING DATA BUS OF ADC1 WITH REFERENCE MANUAL 6.3.12 RCC APB2ENR*/
			RCC->APB2ENR |= ADC1EN;
			/*4. CONVERSION SEQUENCE START
			SEQUENCE REGISTER FOR CHANNEL 1 WITH REFERENCE MANUAL 11.12.11 */
			ADC1->SQR3 = ADC_CH1;
			//SEQUENCE REGISTER FOR LENGTH OF CONVERSION WITH REFERENCE MANUAL 11.12.9
			ADC1->SQR1 = ADC_SEQ_LEN_1;

			//CONTROL REGISTER TO ENABLE ADC MODULE WITH REFERENCE MANUAL 11.12.3
			ADC1->CR2 |= CR2_ADON;

}

void start_conversion(void)
{
	//CONTROL REGISTER TO ENABLE CONTINUOUS CONVERSION
	ADC1 ->CR2 |= CR2_CONT;

	//CONTROL REGISTER TO ENABLE START CONVERSION
	ADC1 ->CR2 |= CR2_SWSTART;
}

uint32_t adc_read(void)
{
	//STATUS REGISTER TO CHECK CONVERSION COMPLETE OR NOT WITH REFERENCE MANUAL 11.12.1
	while(!(ADC1 ->SR & SR_EOC))
	{

	}
	 //WHEN CONVERSION COMPLETED ,RETURN TO DATA REGISTER
	return (ADC1 ->DR);
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Header file:

/*
 * ADC_with_Interrupt.h
 *
 *  Created on: Jan 28, 2026
 *      Author: jeffin
 */

#ifndef INC_ADC_WITH_INTERRUPT_H_
#define INC_ADC_WITH_INTERRUPT_H_

#include <stdint.h>

void PA1_ADC_Init(void);
uint32_t adc_read(void);
void start_conversion(void);
void PA1_ADC_Interrupt_Init(void);

#define SR_EOC          (1<<1)


#endif /* INC_ADC_WITH_INTERRUPT_H_ */
